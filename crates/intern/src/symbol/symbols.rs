//! Module defining all known symbols required by the rest of rust-analyzer.
#![allow(non_upper_case_globals)]

use std::hash::{BuildHasherDefault, Hash as _, Hasher as _};

use dashmap::{DashMap, SharedValue};
use rustc_hash::FxHasher;

use crate::{
    symbol::{SymbolProxy, TaggedArcPtr},
    Symbol,
};

macro_rules! define_symbols {
    (@WITH_NAME: $($alias:ident = $value:literal),* $(,)? @PLAIN: $($name:ident),* $(,)?) => {
        // Ideally we would be emitting `const` here, but then we no longer have stable addresses
        // which is what we are relying on for equality! In the future if consts can refer to
        // statics we should swap these for `const`s and have the the string literal being pointed
        // to be statics to refer to such that their address is stable.
        $(
            pub static $name: Symbol = Symbol { repr: TaggedArcPtr::non_arc(&stringify!($name)) };
        )*
        $(
            pub static $alias: Symbol = Symbol { repr: TaggedArcPtr::non_arc(&$value) };
        )*


        pub(super) fn prefill() -> DashMap<SymbolProxy, (), BuildHasherDefault<FxHasher>> {
            let mut dashmap_ = <DashMap<SymbolProxy, (), BuildHasherDefault<FxHasher>>>::with_hasher(BuildHasherDefault::default());

            let hash_thing_ = |hasher_: &BuildHasherDefault<FxHasher>, it_: &SymbolProxy| {
                let mut hasher_ = std::hash::BuildHasher::build_hasher(hasher_);
                it_.hash(&mut hasher_);
                hasher_.finish()
            };
            {
                $(

                    let proxy_ = SymbolProxy($name.repr);
                    let hash_ = hash_thing_(dashmap_.hasher(), &proxy_);
                    let shard_idx_ = dashmap_.determine_shard(hash_ as usize);
                    dashmap_.shards_mut()[shard_idx_].get_mut().raw_entry_mut().from_hash(hash_, |k| k == &proxy_).insert(proxy_, SharedValue::new(()));
                )*
                $(

                    let proxy_ = SymbolProxy($alias.repr);
                    let hash_ = hash_thing_(dashmap_.hasher(), &proxy_);
                    let shard_idx_ = dashmap_.determine_shard(hash_ as usize);
                    dashmap_.shards_mut()[shard_idx_].get_mut().raw_entry_mut().from_hash(hash_, |k| k == &proxy_).insert(proxy_, SharedValue::new(()));
                )*
            }
            dashmap_
        }
    };
}
define_symbols! {
    @WITH_NAME:

    self_ = "self",
    Self_ = "Self",
    tick_static = "'static",
    dollar_crate = "$crate",
    MISSING_NAME = "[missing name]",
    INTEGER_0 = "0",
    INTEGER_1 = "1",
    INTEGER_2 = "2",
    INTEGER_3 = "3",
    INTEGER_4 = "4",
    INTEGER_5 = "5",
    INTEGER_6 = "6",
    INTEGER_7 = "7",
    INTEGER_8 = "8",
    INTEGER_9 = "9",
    INTEGER_10 = "10",
    INTEGER_11 = "11",
    INTEGER_12 = "12",
    INTEGER_13 = "13",
    INTEGER_14 = "14",
    INTEGER_15 = "15",
    fn_ = "fn",

    @PLAIN:
    add_assign,
    add,
    align_offset,
    alloc_layout,
    alloc,
    as_str,
    asm,
    assert,
    begin_panic,
    bench,
    bitand_assign,
    bitand,
    bitor_assign,
    bitor,
    bitxor_assign,
    bitxor,
    bool,
    box_free,
    Box,
    boxed,
    branch,
    Break,
    c_void,
    call_mut,
    call_once,
    call,
    Center,
    cfg_accessible,
    cfg_attr,
    cfg_eval,
    cfg,
    char,
    clone,
    Clone,
    coerce_unsized,
    column,
    compile_error,
    concat_bytes,
    concat_idents,
    concat,
    const_format_args,
    const_panic_fmt,
    const_param_ty,
    Context,
    Continue,
    copy,
    Copy,
    core_panic,
    core,
    coroutine_state,
    coroutine,
    crate_type,
    CStr,
    Debug,
    default,
    Default,
    deref_mut,
    deref_target,
    deref,
    derive_const,
    derive,
    discriminant_kind,
    discriminant_type,
    dispatch_from_dyn,destruct,
    div_assign,
    div,
    doc,
    drop_in_place,
    drop,
    dyn_metadata,
    eh_catch_typeinfo,
    eh_personality,
    env,
    eq,
    Eq,
    Err,
    exchange_malloc,
    f128,
    f16,
    f32,
    f64,
    feature,
    file,
    filter_map,
    fmt,
    fn_mut,
    fn_once_output,
    fn_once,
    fn_ptr_addr,
    fn_ptr_trait,
    format_alignment,
    format_args_nl,
    format_args,
    format_argument,
    format_arguments,
    format_count,
    format_placeholder,
    format_unsafe_arg,
    format,
    freeze,
    from_output,
    from_residual,
    from_usize,
    from_yeet,
    future_trait,
    future,
    Future,
    ge,
    get_context,
    global_allocator,
    global_asm,
    gt,
    Hash,
    i128,
    i16,
    i32,
    i64,
    i8,
    Implied,
    include_bytes,
    include_str,
    include,
    index_mut,
    index,
    Index,
    into_future,
    into_iter,
    IntoFuture,
    IntoIter,
    IntoIterator,
    is_empty,
    Is,
    isize,
    Item,
    iter_mut,
    iter,
    Iterator,
    le,
    Left,
    len,
    line,
    llvm_asm,
    log_syntax,
    lt,
    macro_rules,
    manually_drop,
    maybe_uninit,
    metadata_type,
    module_path,
    mul_assign,
    mul,
    ne,
    neg,
    Neg,
    new_binary,
    new_debug,
    new_display,
    new_lower_exp,
    new_lower_hex,
    new_octal,
    new_pointer,
    new_unchecked,
    new_upper_exp,
    new_upper_hex,
    new_v1_formatted,
    new,
    next,
    no_core,
    no_std,
    none,
    None,
    not,
    Not,
    Ok,
    opaque,
    ops,
    option_env,
    option,
    Option,
    Ord,
    Output,
    owned_box,
    panic_2015,
    panic_2021,
    panic_bounds_check,
    panic_cannot_unwind,
    panic_display,
    panic_fmt,
    panic_impl,
    panic_info,
    panic_location,
    panic_misaligned_pointer_dereference,
    panic_nounwind,
    panic,
    Param,
    partial_ord,
    PartialEq,
    PartialOrd,
    Pending,
    phantom_data,
    pieces,
    pin,
    pointee_trait,
    pointer_like,
    poll,
    Poll,
    prelude,
    quote,
    range_inclusive_new,
    Range,
    RangeFrom,
    RangeFull,
    RangeInclusive,
    RangeTo,
    RangeToInclusive,
    Ready,
    receiver,
    recursion_limit,
    register_attr,
    register_tool,
    rem_assign,
    rem,
    result,
    Result,
    ResumeTy,
    Right,
    rust_2015,
    rust_2018,
    rust_2021,
    rust_2024,
    rustc_coherence_is_core,
    rustc_macro_transparency,
    semitransparent,
    shl_assign,
    shl,
    shr_assign,
    shr,
    sized,
    slice_len_fn,
    Some,
    start,
    std_panic,
    std,
    str,
    string,
    String,
    stringify,
    structural_peq,
    structural_teq,
    sub_assign,
    sub,
    sync,
    Target,
    termination,
    test_case,
    test,
    trace_macros,
    transmute_opts,
    transmute_trait,
    transparent,
    Try,
    tuple_trait,
    u128,
    u16,
    u32,
    u64,
    u8,
    Unknown,
    unpin,
    unreachable_2015,
    unreachable_2021,
    unreachable,
    unsafe_cell,
    unsize,
    usize,
    v1,
    va_list
}
