#![allow(non_upper_case_globals)]

use std::hash::{BuildHasherDefault, Hash as _, Hasher as _};

use dashmap::{DashMap, SharedValue};
use rustc_hash::FxHasher;

use crate::{
    symbol::{SymbolProxy, TaggedArcPtr},
    Symbol,
};
macro_rules! define_symbols {
    ($($name:ident),* $(,)?) => {
        $(
            pub const $name: Symbol = Symbol { repr: TaggedArcPtr::non_arc(&stringify!($name)) };
        )*


        pub(super) fn prefill() -> DashMap<SymbolProxy, (), BuildHasherDefault<FxHasher>> {
            let mut dashmap_ = <DashMap<SymbolProxy, (), BuildHasherDefault<FxHasher>>>::with_hasher(BuildHasherDefault::default());

            let hash_thing_ = |hasher_: &BuildHasherDefault<FxHasher>, it_: &SymbolProxy| {
                let mut hasher_ = std::hash::BuildHasher::build_hasher(hasher_);
                it_.hash(&mut hasher_);
                hasher_.finish()
            };
            {
                $(

                    let proxy_ = SymbolProxy($name.repr);
                    let hash_ = hash_thing_(dashmap_.hasher(), &proxy_);
                    let shard_idx_ = dashmap_.determine_shard(hash_ as usize);
                    dashmap_.shards_mut()[shard_idx_].get_mut().raw_entry_mut().from_hash(hash_, |k| k == &proxy_).insert(proxy_, SharedValue::new(()));
                )*
            }
            dashmap_
        }
    };
}
define_symbols! {
    add_assign,
    add,
    alloc,
    as_str,
    asm,
    assert,
    bench,
    bitand_assign,
    bitand,
    bitor_assign,
    bitor,
    bitxor_assign,
    bitxor,
    bool,
    Box,
    boxed,
    branch,
    call_mut,
    call_once,
    call,
    Center,
    cfg_accessible,
    cfg_attr,
    cfg_eval,
    cfg,
    char,
    Clone,
    column,
    compile_error,
    concat_bytes,
    concat_idents,
    concat,
    const_format_args,
    Copy,
    core_panic,
    core,
    crate_type,
    Debug,
    default,
    Default,
    deref_mut,
    deref,
    derive_const,
    derive,
    div_assign,
    div,
    doc,
    drop,
    env,
    eq,
    Eq,
    f128,
    f16,
    f32,
    f64,
    feature,
    file,
    filter_map,
    fmt,
    fn_mut,
    fn_once,
    format_args_nl,
    format_args,
    format,
    from_usize,
    future_trait,
    future,
    Future,
    ge,
    global_allocator,
    global_asm,
    gt,
    Hash,
    i128,
    i16,
    i32,
    i64,
    i8,
    Implied,
    include_bytes,
    include_str,
    include,
    index_mut,
    index,
    Index,
    into_future,
    IntoFuture,
    IntoIter,
    IntoIterator,
    is_empty,
    Is,
    isize,
    Item,
    iter_mut,
    iter,
    Iterator,
    le,
    Left,
    len,
    line,
    llvm_asm,
    log_syntax,
    lt,
    macro_rules,
    module_path,
    mul_assign,
    mul,
    ne,
    neg,
    Neg,
    new_binary,
    new_debug,
    new_display,
    new_lower_exp,
    new_lower_hex,
    new_octal,
    new_pointer,
    new_upper_exp,
    new_upper_hex,
    new_v1_formatted,
    new,
    next,
    no_core,
    no_std,
    none,
    None,
    not,
    Not,
    Ok,
    ops,
    option_env,
    option,
    Option,
    Ord,
    Output,
    owned_box,
    panic_2015,
    panic_2021,
    Param,
    partial_ord,
    PartialEq,
    PartialOrd,
    pieces,
    poll,
    prelude,
    quote,
    r#fn,
    Range,
    RangeFrom,
    RangeFull,
    RangeInclusive,
    RangeTo,
    RangeToInclusive,
    recursion_limit,
    register_attr,
    register_tool,
    rem_assign,
    rem,
    result,
    Result,
    Right,
    rust_2015,
    rust_2018,
    rust_2021,
    rust_2024,
    shl_assign,
    shl,
    shr_assign,
    shr,
    std_panic,
    std,
    str,
    string,
    String,
    stringify,
    sub_assign,
    sub,
    Target,
    test_case,
    test,
    trace_macros,
    Try,
    u128,
    u16,
    u32,
    u64,
    u8,
    Unknown,
    unreachable_2015,
    unreachable_2021,
    unreachable,
    unsafe_cell,
    usize,
    v1,
    va_list
}
